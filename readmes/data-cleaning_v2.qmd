---
title: "data_cleaning_v1"
format: html
---

**PREP data for cleaning**
1. establish current directory and find directory of all CSV files 
2. establish the column name order of master CSV file 
3. create an empty dfs list
4. start a For loop:
  5. read CSV file - ensure HEADERS False (for later column naming)
  6. transpose the data - columns turn into rows (data), rows turn into columns (column names)
    a.ensure it is done as.data.frame
  8. Assign new column names - first row after transposition
  9. remove original HEADER row  of data frame of that CSV file is V1,V2,V3 ETC (bc of header FALSE) - so REMOVE IT 
  10. Do the columns follow the same order, are any data values missing in the CSV file?
    a. For loop - create variable col - and iterate through col_names (list of column titles made earlier)
    b. if col != col_name = empty = replace with NA
      i. df_t[[col]] - square bracket - changes an element
  11. Then re-order and match the column order of dfs as col_order
  12. Add the CSV file from df_t for loop iteration into the dfs + add 1 more row to the length of dfs (for next)
  13. Bind all rows of list into dataframe - makes longer result.
  14. Ensure MGI + Mouse strain is uppercase uppercase


```{r}
library(tidyverse)
library(tidyr)




# locate file 
all_data<- list.files(pattern = '*.csv',path = "../group5/data/", full.names = TRUE)

# generate random sample of 10% of data (~29k files) to work with 
set.seed(88880888)
working_data <- sample(all_data, 300, replace = FALSE, prob = NULL)

#unique(sampling_data)


col_order <- c("gene_accession_id","analysis_id", "gene_symbol", "mouse_strain", "mouse_life_stage", "parameter_id", "parameter_name" , "pvalue")

#Change the path where the files are located

dfs <- list()
#make an empty list for the loop

for (path in working_data){
  df <- read.csv(path, header = FALSE, stringsAsFactors = FALSE)
  #header = FALSE: V1,V2,V3,V4 are the HEADERS 
    # r reads the files - after transposing - as FIRST ROW OF DATA = later becoming the column names
  
  #transpose the data as a dataframe into dfs
  df_t <- as.data.frame(t(df), stringsAsFactors = FALSE)
  
  #ASSIGNING COLUMN NAMES - as  first row after transposition
  colnames(df_t) <- df_t[1,] 
  
  df_t <- df_t[-1, ] #removing the original header row
  
  
  for (col in col_order){
    # create variable called col so that it can iterate through col_order
    
    if (!col %in% colnames(df_t)){
      df_t[[col]] <- NA # ensure every dataframe (row) has same columns by adding missing ones as NA, so that they can be merged row-wise
      #col - already represented as one of the col_order variables which IF THEY ARE NOT one of the colnames in df_t, then create an NA group for it in that area
                
    }
  }

  
  df_t <- df_t[,col_order] #re-order and match the columns in the same order as col_order
  #add row to list
  dfs[[length(dfs) + 1]] <- df_t
  # puts the df_t csv file (from this current for loop iteration) into the dfs list
  # stores the WHOLE DATAFRAME as one item in the list
}
  

?bind_rows()

merged_df <- bind_rows(dfs)

# Write output to new CSV
write.csv(merged_df, "merged_transposed.csv", row.names = FALSE)
merged_df <- as.data.frame(merged_df)

##################find all NA values######################################
na_counts <- lapply(merged_df, function(x) sum(is.na(x)))
print(na_counts)

na_df <- data.frame(column = names(na_counts),
                    na_count =  as.numeric(na_counts)
)

#loop helps to find inconsistancies - sometimes lower/upper case changes in mouse_life_stage or mouse_Strain# and for finding NA's in these categories
names <- c("mouse_strain", "mouse_life_stage")
for (x in names){
  print(unique(merged_df[[x]]))
}


colnames(merged_df) <- tolower(colnames(merged_df))
#Ensure all column headers are lowercase


```

** SOP Normalization** ALL TESTED ON SAMPLE DATASET FIRST

1. Convert column header into lowercase
2. ensure dataType is consistant 
3. Ensure minValue/maxValue is Consistant 
4. start with string + move onto pvalue (as.numeric for float)
cvd- column valid data (abbreviated variable)

*NOTE - ADAPTED FROM https://www.ucl.ac.uk/~ucjtwyc/teaching/Intro_R_Programming_Jan2012.pdf? = UCL LECTURE on R programming concepts. AND reddit thread: https://www.reddit.com/r/rstats/comments/azumgy/is_there_a_summarylike_function_which_gives_nchar/ *

```{r}
library(tidyverse)
library(tidyr)


#create dataframe called sop + have parameters of IMPC_SOP in dataframe#
sop <- list(
  analysis_id = list(type = "string", minValue = 15, maxValue = 15, constraints = c()),
  gene_accession_id = list(type = "string", minValue = 9, maxValue = 11, constraints = c()),
  gene_symbol = list(type = "string", minValue = 1, maxValue = 13, constraints = c()),
  mouse_strain = list(type = "string", minValue = 3, maxValue = 5, constraints = c("C57BL", "B6J", "C3H", "129SV")),
  mouse_life_stage = list(type = "string", minValue = 4, maxValue = 17, constraints = c("E12.5", "E15.5", "E18.5", "E9.5", "Early adult", "Late adult", "Middle aged adult")),
  parameter_id = list(type = "string", minValue = 15, maxValue = 20, constraints = c()),
  parameter_name = list(type = "string", minValue = 2, maxValue = 74, constraints = c()),
  pvalue = list(type = "float", minValue = 0, maxValue = 1, constraints = c())
)



##ANALYSIS ID + GENE_ACCESSION_ID + GENE_SYMBOL + PAPRAMETER_ID + PARAMETER_NAME + P_VALUE ##

cvd <- function(x, sop) {
  res = 0
  # set res to o + function is x (input), sop - sop value name
  
  if (sop$type == "string")
  {
    res = which(nchar(x) < sop$minValue | nchar(x) > sop$maxValue)
    #return those of which character length is outside the given range from sop
    
    if (!is.null(sop$constraints))
      # if the sop dataframe value for constrains is not NULL (which all are except 2) then go ahead
      res = which(!(x %in% sop$constraints))
    #return those of which are NOT in the sop constraints list
  }
  else if (sop$type == "float")
    #else for the pvalue (float) if it is outside given range 0-1 then return the row value.
    res = which(x < sop$minValue | x > sop$maxValue)

  return(res)
}



anal_cvd <- cvd(merged_df$analysis_id , sop$analysis_id)
#returned integer = 0 - meaning that NO analysis_id exceeded the number of characters (nchar)

gene_acc_cvd <- cvd(merged_df$gene_accession_id, sop$gene_accession_id)
gene_symb_csv <- cvd(merged_df$gene_symbol, sop$gene_symbol)

strain_cvd <- cvd(merged_df$mouse_strain, sop$mouse_strain)
stage_cvd <- cvd(merged_df$mouse_life_stage , sop$mouse_life_stage)
#this shows that rows 12 and 87 show mouse strains not mentioned in the stage array 
#merged_df[12,]
  # error on line 12 is due to capital casing issue
#merged_df[87,]
  # error on line 87 - NA


param_cvd <-cvd(merged_df$parameter_id , sop$parameter_id)
par_name_cvd <- cvd(merged_df$parameter_name , sop$parameter_name)
pval_cvd <- cvd(merged_df$pvalue , sop$pvalue)

#returned rows = 55. 91 - meaning that pvalues on these rows exceeded 1 or less than 0
#merged_df[55,] # row 55 , pvalue = 1.338161 (error)?
#merged_df[91,] #row 91, pvalue = 1.468044

sop["analysis_id"]
print(merged_df$analysis_id)
merged_df["analysis_id"][1,]

#ENSURE THAT MOST COLUMNS (OTHER THAN P VALUE) ARE CLASSED AS CHARACTER:
col_strings_ty<- merged_df[,1:6]
for (headline in col_strings_ty){
  as.character(merged_df$headline)
}

#ENSURES P VALUE IS CLASSED AS DOUBLE (FLOAT)
options(scipen=888)
merged_df$pvalue <- as.double(merged_df$pvalue)






```

** FIND THE NA's and DUPLICATES OF ALL ROWS**
1. flag all duplicates
2. SOP - Datatype conversion
3. Find NA's in columns of data 
4. plot NA

```{r}
library(ggplot2)

if (any(duplicated(merged_df))) { # marks the rows which appear more than once
  
  duplicate_rows <- merged_df[duplicated(merged_df) | duplicated(merged_df, fromLast = TRUE), ]
  # finds duplicates scanning top down (this only flags second value), then pipes this into the next part and scans bottom up to flag the 'second duplicate' (the ignored first one)
  duplicate_rows
}



ggplot(na_df, aes(reorder(column, -na_count), y = na_count))+
  geom_histogram(stat = 'summary')

```



** Disease information.CSV - CLEANING **

1. Proof reading and normalization - check datatypes, caps, column 
2. convert into lower case
3. check for NA

```{r}
dis_inf <- read.csv("../group5/Disease_information.csv", header = FALSE, sep =",", stringsAsFactors = FALSE)
str(dis_inf)
#check data types
as.character(dis_inf)
str(dis_inf)

colnames(dis_inf) <- tolower(colnames(dis_inf))


col_order <- c("Mouse MGI ID","DO Disease ID", "DO Disease Name", "OMIM IDs")

```


**IMPC proceducre